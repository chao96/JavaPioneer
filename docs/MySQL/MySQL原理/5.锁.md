

## 一、数据库锁

Mysql锁大致可分为全局锁、表级锁、行锁

### 1.全局锁

对整个数据库实例加锁。

**典型场景为**：做全库逻辑备份

> 可重复读隔离级别，可以确保拿到一个一致性视图。由于MVCC的支持，这个过程中数据可以正常更新。

### 2.表级锁

当对一个表做增删改查操作的时候加MDL读锁；对表做结构变更时，加MDL写锁。

+ 读锁之间不互斥
+ 读写锁之间、写锁之间互斥

### 3. 行锁

InnoDB事务中，行锁在需要时加上，等到事务结束时释放。这个就是两阶段锁协议

> 如果事务中需要锁多个行，要把最可能造成索冲突、最可能影响并发读的锁尽量往后放。



## 二、死锁和死锁检测

出现死锁后有两种策略：

+ 1.进入等待、直到超时
+ 2.发起死锁检测，发现死锁后，主动回滚死锁链条中某个事务。



**死锁检测**

怎么解决热点行更新堵住线程导致的性能问题？

1.如果能确保业务不会出现死锁，可以临时关掉死锁检测。

2.控制并发度

## 三、加锁规则（可重复读隔离级别）

间隙锁在可重复读隔离级别下才有效

1.原则1：加锁基本单位是next-key lock，前开后闭区间。

2.原则2：查找过程中访问到的对象才会加锁

3.优化1：索引上的等值查询-唯一索引时，next-key lock 退化为行锁

4.优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁

5.一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。