## 一、如何判断对象可以回收

### 1.引用计数法

变量被引用数为0时可被回收。

缺陷：不能解决循环引用

### 2.可达性分析算法

通过GC Root并沿着路径找到所有堆中被引用的对象，并进行标记，没被标记的就是不可达对象。

**可作为GC Root的对象：**

+ 虚拟机栈中的引用的对象
+ 方法区中类静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈中JNI（Native方法）引用的对象

### 3.四种引用

**①强引用**

所有GC Roots对象都不通过强引用引用该对象，该对象才能被垃圾回收。

**②软引用**

仅有软引用引用该对象时，在垃圾回收后内存仍不足时会再次垃圾回收，回收软引用对象。

可以配合引用队列来释放软引用自身

**③弱引用**

仅有弱引用引用该对象时，在垃圾回收时，会回收弱引用对象。

可以配合引用队列来释放弱引用自身

**④虚引用**

必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，
由 Reference Handler 线程调用虚引用相关方法释放直接内存

## 二、垃圾回收算法

### 1.标记清除

分为**标记**和**清除**两个阶段：首先标记出可达的对象，然后清除未标记的对象。

会产生大量不连续的内存碎片

### 2.标记整理

标记整理是在标记清除算法上的优化，执行完标记后将所有存活对象统一向一端移动，解决内存碎片问题。

效率低

### 3.复制

将标记的对象复制到新的内存空间，清空原内存空间。

不会有内存碎片，但需要占用双倍内存空间。

## 三、分代垃圾回收

![](/img/2.jpg)

+ 对象首先分配在新生代-伊甸园区域
+ 新生代空间不足时，触发minor gc，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄加1，交换from、to区
+ gc时会暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行
+ 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15
+ 当老年代空间不足，会先尝试minor gc，如果空间仍不足，那么触发full gc。

### 1.相关VM参数

| 参数               | -Xms                                                         |
| ------------------ | ------------------------------------------------------------ |
| 堆初始大小         | -Xms                                                         |
| 堆最大大小         | -Xmx 或 -XX:MaxHeapSize=size                                 |
| 新生代大小         | -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )            |
| 幸存区比例（动态） | -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy |
| 幸存区比例         | -XX:SurvivorRatio=ratio                                      |
| 晋升阈值           | -XX:MaxTenuringThreshold=threshold                           |
| 晋升详情           | -XX:+PrintTenuringDistribution                               |
| GC详情             | -XX:+PrintGCDetails -verbose:gc                              |
| FullGC 前 MinorGC  | -XX:+ScavengeBeforeFullGC                                    |



## 四、垃圾回收器

### 1.串行

> -XX:+UseSerialGC =  Serial + SerialOld

单线程，适合堆内存较小

### 2.吞吐量优先

> XX:+UseParallelGC   - XX:+UseParallelOldGC

多线程，堆内存较大，多核cpu（单位时间内STW时间短）

![](/img/3.jpg)

### 3.响应时间优先

> - XX:+UseConcMarkSweepGC ~  - XX:+UseParNewGC ~  SerialOld

多线程，堆内存较大，多核cpu。（尽可能让单次STW时间变短）

### 4.G1

**适用场景：**

+ 同时注重吞吐量和低延迟，默认的暂停时间是200ms
+ 超大堆内存，会将堆划分为多个大小相等的Region
+ 整体上是标记整理算法，两个区域之间是复制算法

**相关JVM参数：**

```properties
-xx:+UseGlGC
-xx:GlHeapRegionSize=size
-xx:MaxGCPauseMillis=time
```

## 五、垃圾回收调优

### 1.调优领域

内存、锁竞争、cpu占用、io

### 2.确定目标

低延迟还是高吞吐量，选择合适的回收器

### 3.最快的GC

> 最快的GC是不发生GC

查看Full GC前后的内存占用：

①数据是不是太多？

②数据表示是否太臃肿？

③是否存在内存泄露？

### 4.新生代调优

新生代内存设置：

+ 新生代能容纳所有【并发量*（请求-响应）】的数据
+ 幸存区大到能保留【当前活跃对象+需要晋升对象】
+ 晋升阈值配置得当，让长时间存活对象尽快晋升

### 5.老年代调优



### 6.案例

**案例1：Full GC和Minor GC频繁**

可能新生代内存设置太小，频繁晋升

**案例2：请求高峰期发生Full GC，单次暂停时间特别长**

**案例3：老年代充裕情况下，发生Full GC**

jdk1.7永久代设置小了会发生Full GC