> 每天对自己说一句：早安！

* [目录](#目录)
    * [事务隔离的实现](#事务隔离的实现)


# 目录

    * [事务隔离的实现](#事务隔离的实现)



提到事务，肯定会想到 ACID （ Atomicity 、 Consistency、 Isolation 、 Durability ，即原子性、一致性、隔离性、持久性）

**隔离性**

当多个事务同时执行的时候，就可能出现脏读（ dirty read ）、不可重复读（ non-repeatable read ）、幻读（phantom read ）的问题，为了解决这些问题，就有了 “ 隔离级别 ” 的概念。隔离的越严实效率越低。

**隔离级别**

+ 读未提交：一个事务还没提交，它做的变更就能被别的事务看到。
+ 读已提交：一个事务提交之后，它做的变更才会被其他事务看到。
+ 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
+ 串行化：对同一行记录， “ 写 ” 会加 “ 写锁 ” ， “ 读 ” 会加 “ 读锁 ” 。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

**查看mysql隔离级别**

```mysql
show variables like 'transaction_isolation';
```

### 事务隔离的实现

 MySQL 中，每条记录在更新的时候都会同时记录一条回滚操作（undo log）。通过回滚操作，都可以得到前一个状态的值。

**“ 快照 ” 在 MVCC 里是怎么工作的？**

在可重复读隔离级别下，事务在启动的时候就 “ 拍了个快照 ” 。注意，这个快照是基于整库的。

InnoDB 里面每个事务有一个唯一的事务 ID ，叫作transaction id 。它是在事务开始的时候向InnoDB 的事务系统申请的，是按申请顺序严格递增的。

数据表中的一行记录，可能有多个版本 (row) ，每个版本有自己的 row trx_id 

> 每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个新数据版本的事务 ID ，记为 row trx_id 。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

