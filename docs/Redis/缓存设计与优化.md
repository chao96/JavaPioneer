
# 一、缓存的收益与成本
## 1.收益
+ 加速读写
+ 降低后端负载：业务端使用Redis降低后端Mysql负载

## 2.成本
+ 数据不一致
+ 代码维护成本：多了一层缓存逻辑
+ 运维成本：例如Redis Cluster

## 3.使用场景
+ 降低后端负载：对高消耗的sql，join结果集/分组统计结果缓存
+ 加速请求响应：优化IO响应时间
+ 大量写合并为批量写：如计数器先Redis累加再批量写DB

# 二、缓存更新策略

## 1.LRU/LFU/FIFO算法剔除

## 2.超时剔除：expire

## 3.主动更新：开发控制生命周期，如修改时删除缓存

**两条建议**
1）低一致性：最大内存和淘汰策略
2）高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底

# 三、缓存粒度控制
## 1.三个角度
+ 通用性：全量属性更好
+ 占用空间：部分属性更好
+ 代码维护：表面上全量属性更好。

# 四、缓存穿透优化
## 1.大量请求不命中
+ 业务代码自身问题
+ 恶意攻击、爬虫等等

## 2.如何发现
+ 业务的响应时间
+ 业务本身问题
+ 相关指标：总调用数，缓存层命中数，存储层命中数

## 3.解决方法
1） 缓存空对象：将获取到的空对象加入到缓存，设置过期时间
+ 需要更多的键
+ 缓存层和存储层数据“短期”不一致

2）布隆过滤器拦截

# 五、缓存雪崩优化
缓存同一时间大面积失效，后面的请求都会落到数据库上，造成数据库短时间承受大量请求而崩掉


# 六、无底洞问题优化
加机器性能没提升，反而下降

# 七、热点key重建优化
问题描述：热点key + 较长的重建时间（高并发）

## 1.三个目标
+ 减少重建缓存的次数
+ 数据尽可能一致
+ 减少潜在危险（死锁）

## 2.两个解决
+ 互斥锁
+ 永远不过期