## 同步机制解决线程安全问题
### 一、同步代码块

```java
synchronized(同步监视器){
	//需要被同步的代码
}
```

**注意**

+ 1.操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。

*    2.共享数据：多个线程共同操作的变量。比如：买票时的票数。
*    3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
*    要求：多个线程必须要共用同一把锁。

**补充**：

+ 在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。

+ 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。

### 二、同步方法

```java
private synchronized void show(){//同步监视器：this
  //需要同步的代码
}
```

如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

关于同步方法的总结：

+ 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明
+ 非静态的同步方法，同步监视器是：this

*  静态的同步方法，同步监视器是：当前类本身

### 三、Lock锁

**synchronized 与 Lock的异同**？

相同：二者都可以解决线程安全问题

不同：

+ synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
+ Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）

```java
//1.实例化ReentrantLock
private ReentrantLock lock = new ReentrantLock();
@Override
public void run() {
  try{
    //2.调用锁定方法lock()
    lock.lock();
    //3.需要同步的代码
  }finally {
    //4.调用解锁方法：unlock()
    lock.unlock();
  }
}
```

### 四、使用的优先顺序

**Lock** ---> **同步代码块**（已经进入了方法体，分配了相应资源 ) --->**同步方法**（在方法体之外)

**优缺点**：

+ 好处：同步的方式，解决了线程的安全问题
+ 坏处：操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。

****