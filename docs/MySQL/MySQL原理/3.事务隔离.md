**事务隔离机制**

## 一、隔离性与隔离级别

多事务同时执行时：可能会出现**脏读、不可重复读、幻读**问题。

**脏读**：事务A读取了事务B更新但未提交的数据，然后事务B回滚，那么A读的数据是脏数据。

**不可重复读**：事务A多次读取同一数据，事务B在期间对数据作了更新并提交，导致事务A多次读取同一数据，但结果不一致。

**幻读**：一个事务在前后两次查询同一个范围的时候，后一次看到了前一次查询没有看到的行。幻读一般指新插入的行。（比如事务A将所有学生成绩从分数改为ABCD等级，事务B这时插入了一条具体分数记录，事务A改完后发现还有一条记录没有改过来，像发生幻觉一样）



**隔离级别**：

**读未提交**：一个事务还没提交，所做的变更就能被别的事务看到。

**读已提交**：一个事务提交之后，做的变更才会被其他事务看到。

**可重复读**：一个事务执行过程中看到的数据，跟事务启动时看到的数据是一致的。

**串行化**：出现读写锁冲突时，后访问的事务必须等前一个事务完成。



## 二、MVCC机制

一致性视图实在执行第一个sql语句时开启的。

InnoDB里面每个事务有一个唯一的事务ID，，一行数据可能有多个版本，每个版本有自己的row trx_id。

InnoDB为每个事务构建了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID（启动了但还没提交）

**核心概念**

数组里事务ID最小值记为**低水位**，系统里已经创建过的事务ID最大值加1为**高水位**。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

1.**数据版本在低水位**，表示这个版本是已提交的事务，可见。

2.**数据版本在高水位**，表示是后面启动的事务，不可见。

3.**数据版本在中间**，分两种情况：

+ 若row trx_id在数组中，表示由还没提交的事务生成，不可见
+ 若row trx_id不在数组中，表示由已提交事务生成，可见

**更新数据都是先读后写的，而这个读只能读当前的值，称为“当前读”（current read）**

> 除了update语句外，select 语句如果加锁也是当前读
>
> 比如：
>
> select k from t where id=1 lock in share mode;
>
> select k from t where id=1 for update;

可重复读的核心就是一致性读；而事务更新数据时，只能用当前读。

+ **可重复读隔离级别下**：事务开始时创建一致性视图，之后事务里其他查询共用这个一致性视图。
+ **读提交隔离级别下**：每个语句执行前都会重新算出一个新的视图

## 三、幻读的问题

### 1.幻读会导致

**1）语义上的问题。**

**2）数据一致性问题。**（当用binlog恢复数据可能会出问题）

### 2.如何解决幻读？

**间隙锁**（Gap Lock）

间隙锁和行锁合称**next-key lock**，每个**next-key lock**是前开后闭区间

间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的

**注意：**

间隙锁是在可重复读隔离级别下才会生效的。如果把隔离级别设置为读提交的话，就没有间隙锁了。但要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row（row模式下日志记录每一行数据被修改的形式）