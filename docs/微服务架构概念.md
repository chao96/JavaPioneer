## 一、微服务介绍

### 1.什么是微服务

服务一个相对较小且独立的功能单元

### 2.微服务由来

微服务架构风格是使用一套小服务来开发单个应用的方式，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是（HTTP API），独立部署，这些服务可使用不同的编程语言实现，以及不同的数据存储技术，并保持最低限度的集中式管理。

### 3.为什么需要微服务

传统的IT行业软件大多都是各种独立系统的堆砌，扩展性查，可靠性不高，维护难。后面引入SOA服务化，但SOA早期使用总线模式是与某种技术栈强绑定的，遗留系统很难对接，切换时间长成本高。

#### 3.1早期的单体架构带来的问题

单体架构在规模小的时候工作良好，系统规模扩大后，问题比较多：

①复杂性变高

代码越多复杂性越高，各模块之间区别比较模糊。

②技术债务逐渐上升

人员流动越大，新员工进来接手难

③部署速度逐渐变慢

单体架构模块非常多，启动项目时间长，浪费开发时间。

④无法按需伸缩

可能扩展某个模块影响其他模块

#### 3.2微服务与单体架构区别

单体架构：代码耦合在一起；共用一个数据库方式单一；所有模块开发使用的技术一样。

微服务：每个模块相当于一个独立的项目；每个模块可以使用不同的存储方式；每个模块可以使用不同的开发技术。

#### 3.3微服务与SOA区别

微服务本质意义还是SOA架构。但微服务不绑定某种特殊的技术，在微服务的系统中，可以有java编写的服务，也可以有Python编写的服务，通过Restful架构风格统一成一个系统。微服务本身与具体技术实现无关，扩展性强。

### 4.微服务本质

微服务在于系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级。微服务与微服务之间在结构上松耦合，在功能上表现为一个统一的整体。统一风格的界面、权限管理、安全策略、上线过程、日志、调度方式、访问入口等。

**微服务的目的是**：有效的拆分应用，实现敏捷开发和部署

### 5.什么样的项目适合微服务

微服务可以按业务功能本身的独立性来划分。

### 6.微服务拆分与设计

拆分的大原则是当一块业务不依赖或极少依赖其它服务，有独立的业务语义，为超过两个的其它服务或客户端提供数据，那么它就应该被拆分为一个独立的服务模块。

#### 6.1微服务设计原则

①单一职责原则。

②服务自治原则。每个微服务可以当成一个项目，不必依赖于其它模块。

③轻量级通信原则。跨平台、跨语言

④接口明确原则。接口尽可能通用、灵活，避免接口变化后其它模块也做调整。

### 7.微服务优势与缺点

#### 7.1 特性

每个服务为独立的业务开发。

#### 7.2 特点

易于开发和维护、启动快、容易部署、技术栈不受限、按需伸缩。

#### 7.3缺点

运维要求较高。分布式的复杂性。接口调整成本高。重复劳动（如工具类）

### 8.微服务开发框架

目前流行的Spring Cloud、Dubbo

### 9.Spring Cloud和Spring Boot区别

Spring Boot：基于Spring的一套快速开发工具包。简化配置流程。

Spring Cloud：微服务工具包，为开发者提供了在分布式系统的配置管理、服务发现、断路器、智能路由、微代理、控制总线等开发工具包。

## 二、微服务实践先知

### 1.客户端如何访问这些服务？（API Gateway）

后端N个服务和UI之间会有一个代理或者叫API Gateway。

作用是：

提供统一服务入口，让微服务对前台透明；

聚合后台的服务，节省流量，提升性能；

提供安全，过滤，流控等API管理功能

### 2.服务之间如何通信？（服务调用）

RESTful服务、RPC调用、异步消息调用

### 3.这么多服务怎么查找？（服务发现）

微服务架构中，一般一个服务都是有多个拷贝，用作负载均衡。一个服务随时可能下线，也可能应对临时访问压力新增加新的服务节点。基本是通过ZooKeeper等类似技术做服务注册信息的分布式管理。

### 4.服务挂了怎么办？

我们必须确保任一环节出问题都不至于影响整体链路，手段有：

重试机制、限流、熔断机制、负载均衡、降级。

### 5.微服务需要考虑的问题

+ API Gateway
+ 服务间调用
+ 服务发现
+ 服务容错
+ 服务部署
+ 数据调用

## 三、微服务重要部件

### 1.微服务基本能力



### 2.服务注册中心

服务之间需要创建一种服务发现机制，用于帮助服务之间互相感知彼此的存在。服务启动时会将自身的服务信息注册到注册中心，并订阅自己需要消费的服务。

服务注册中心是服务发现的核心。保存了各个可用服务实例的网络地址。服务注册中心必须要有高可用性和实时更新功能。有Eureka、ZooKeeper。

#### 2.1 ZooKeeper服务注册和发现

Zookeeper提供了”心跳检测“功能，定时向各个服务提供者发送一个请求。

ZooKeeper（leader选举），确保服务注册表的高可用性。

### 3.负载均衡

服务高可用的保证手段，为了保证高可用，每一个微服务都需要部署多个服务实例提供服务。此时需要进行负载均衡。

#### 3.1 负载均衡的常见策略

①随机

把来自网络的请求随机分配给内部中多个服务器

②轮询

轮流分配给内部的服务器

③加权轮询

根据服务器的不同处理能力，给每个服务器分配不同比例的请求。

④最少连接数

### 4.容错

调用服务集群时，如果一个微服务调用异常（超时、连接异常、网络异常等），则根据容错策略进行服务容错。目前支持的服务容错策略有快速失败、失效切换。连续失败多次直接熔断不再发起调用。避免一个服务异常拖垮其它依赖服务。

#### 4.1容错策略

①快速失败

服务只发起一次调用，失败立即报错。

②失效切换

服务发起调用，当出现失败后，重试其它服务器。可以设置重试次数。

③失败安全

当服务调用出现异常时，直接忽略。通常用于写入日志操作

④失败自动回复

记录失败请求，定时重发。通常用于消息通知

⑤forking Cluster

并行调用多个服务器，只要有一个成功即返回。通常用于实时性较高的读操作。

⑥广播调用

广播调用所有提供者，任何一台失败则失败。通常用于通知所有提供者更新缓存或日志等本地资源信息。

### 5.熔断

“智能化的容错”，当调用满足失败次数，失败比例就会触发熔断器打开，有程序自动切断当前的RPC调用。实现熔断器主要考虑三种模式：关闭、打开、半开。

### 6.限流和降级

**限流：**

保证核心服务的稳定性。需要为系统能够处理的服务数量设置一个极限阈值，超过这个阈值的请求直接拒绝。

限流方法：令牌桶、漏桶、信号量等。

**降级：**

可以对某些非核心服务进行降级，通过限制服务的最大访问量进行限流，通过管理控制台对单个微服务进行人工降级。

### 7.SLA

服务等级协议



### 8.API网关

将所有API调用统一接入到API网关层，由网关层统一接入和输出。网关的基本功能有：统一接入、安全防护、协议适配、流量管控、容错能力。有了网关之后，各API服务提供团队可以专注于自己的业务处理，而API网关更关注于安全、流量、路由等。

### 9.多级缓存

通过JVM Cache作为应用内的一级缓存（一般是体积小，访问频率大）。

redis作为二级缓存。

### 10.超时和重试

超时和重试机制也是容错的一种方法。对每一个RPC调用都要设置超时时间。对于强依赖RPC调用资源的情况，还要有重试机制设置重试次数。

### 11.线程池隔离

线程隔离使得网关保证局部问题不会影响全局。比如业务订单、商品、用户，如果不做线程隔离当访问订单服务出现网络故障导致延时，线程积压最终导致整个服务CPU负载满。

### 12.网关监控和统计

API网关是一个串行的调用，那么每一步发生的异常要记录下来，统一存储到一个地方比如elasticsearch中，便于后续对调用异常的分析。





