**内存结构**

> JVM内存结构大致为五个部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区

![](/img/1.png)

## 一、程序计数器

**作用**：记住下一条JVM指令的执行地址。

**特点**：是线程私有的，不会存在内存溢出。

## 二、虚拟机栈

### 1.定义

+ 每个线程运行时所需要的内存，称为虚拟机栈
+ 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。
+ 每个线程只能有一个活动栈帧，对应着当前正在执行的方法。

**栈帧：**每个方法运行时需要的内存（参数、局部变量、返回地址）



**问题辨析**

**1.垃圾回收是否涉及栈内存？**

不需要，方法调用完会自动弹出栈

**2.栈内存分配越大越好吗？**

因为物理内存一定，栈内存分配越大，则线程数越少。

**3.方法内的局部变量是否线程安全？**

线程安全，是线程私有的。

### 2.栈内存溢出

> -Xss设置栈内存大小，如：Xss256k

**出现情况**：

+ 栈帧过多（递归死循环）
+ 栈帧过大

### 3.线程运行诊断

**案例1：cpu占用过多**

+ 用 top定位哪个进程对cpu的占用过高
+ ps H -eo pid,tid,%cpu | grep  进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）
+ jstack  线程id。可以根据线程 id 找到有问题的线程，进一步定位到问题代码的行号

**案例2：java线程死锁**

①方法一：通过jconsole控制台查看。

②方法二：使用jps + jstack

+ jps -l：输出java进程id、类的全路径
+ jstack -l pid ：查看进程中各个线程的运行情况

## 三、本地方法栈

给本地方法（native）运行提供内存空间

## 四、堆

### 1.定义

通过new关键字，创建对象都会使用堆内存

**特点：**

+ 它是线程共享的，堆中对象都需要考虑线程安全问题
+ 有垃圾回收机制

### 2.堆内存溢出

> java.lang.OutOfMemoryError: Java heap space

-Xmx8m

### 3.堆内存诊断

①jps工具

+ 查看当前系统中有哪些java进程

②jmap工具

+ 查看堆内存占用情况（jmap -heap 进程id）

③jconsole工具

+ 图形界面的，多功能的监测工具，可以连续监测

**案例：**垃圾回收后，内存占用仍然很高

使用jvisualVM查看当前堆内存快照

## 五、方法区

### 1.定义

+ 所有jvm线程共享的区域
+ 存储了类结构相关的信息，运行时常量池、字段、方法等
+ 在虚拟机启动时创建

### 2.组成

元空间：由类、类加载器、常量池组成

### 3.方法区内存溢出

> -XX:MaxMetaspaceSize-8m
>
> java.lang.OutOfMemoryError: Metaspace

1.8以前会导致永久代内存溢出

1.8以后会导致元空间内存溢出

### 4.运行时常量池

+ 常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、

### 5.String Table

①String Table特性

+ 常量池中的字符串仅是符号，第一次用到时才变为对象。
+ 利用串池的机制，来避免重复创建字符串对象
+ 字符串变量拼接的原理是StringBuilder（1.8）
+ 字符串常量拼接的原理是编译器优化
+ 可以使用intern方法主动将串池中还没有的字符串对象放入串池

> 1.8  将字符串对象放入串池，如果有不会放入，如果没有则放入， 并把串池中的对象返回。
>
> 1.6  将字符串对象放入串池，如果有不会放入，如果没有会把对象复制一份放入串池， 把串池中对象返回

②String Table位置

存放在堆中

③String Table垃圾回收

④String Table性能调优

> -XX:StringTableSize=桶个数

设置桶大小



## 六、直接内存

### 1.定义

直接内存属于操作系统内存，java代码可以直接访问

+ 常见于NIO操作时，用于数据缓冲区
+ 分配回收成本较高，但读写性能高
+ 不受JVM内存回收管理

### 2.分配和回收原理

+ 使用Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法
+ ByteBuffer的实现类内部，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存

